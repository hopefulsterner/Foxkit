{"$message_type":"diagnostic","message":"variable `m` is not bound in all patterns","code":{"code":"E0408","explanation":"An \"or\" pattern was used where the variable bindings are not consistently bound\nacross patterns.\n\nErroneous code example:\n\n```compile_fail,E0408\nmatch x {\n    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n                                      //        not bound in pattern #2\n    _ => ()\n}\n```\n\nHere, `y` is bound to the contents of the `Some` and can be used within the\nblock corresponding to the match arm. However, in case `x` is `None`, we have\nnot specified what `y` is, and the block will use a nonexistent variable.\n\nTo fix this error, either split into multiple match arms:\n\n```\nlet x = Some(1);\nmatch x {\n    Some(y) => { /* use y */ }\n    None => { /* ... */ }\n}\n```\n\nor, bind the variable to a field of the same type in all sub-patterns of the\nor pattern:\n\n```\nlet x = (0, 2);\nmatch x {\n    (0, y) | (y, 0) => { /* use y */}\n    _ => {}\n}\n```\n\nIn this example, if `x` matches the pattern `(0, _)`, the second field is set\nto `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\ncases `y` is set to some value.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/input.rs","byte_start":4573,"byte_end":4592,"line_start":166,"line_end":166,"column_start":13,"column_end":32,"is_primary":true,"text":[{"text":"            (Key::Char('V'), _) | (Key::Char('v'), m) if m.shift => {","highlight_start":13,"highlight_end":32}],"label":"pattern doesn't bind `m`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/input.rs","byte_start":4612,"byte_end":4613,"line_start":166,"line_end":166,"column_start":52,"column_end":53,"is_primary":false,"text":[{"text":"            (Key::Char('V'), _) | (Key::Char('v'), m) if m.shift => {","highlight_start":52,"highlight_end":53}],"label":"variable not in all patterns","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0408]\u001b[0m\u001b[1m: variable `m` is not bound in all patterns\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/input.rs:166:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             (Key::Char('V'), _) | (Key::Char('v'), m) if m.shift => {\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m                    \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mvariable not in all patterns\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91mpattern doesn't bind `m`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this method takes 1 argument but 0 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates/editor/src/commands.rs","byte_start":1253,"byte_end":1255,"line_start":38,"line_end":38,"column_start":35,"column_end":37,"is_primary":false,"text":[{"text":"                editor.delete_word();","highlight_start":35,"highlight_end":37}],"label":"argument #1 of type `bool` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/commands.rs","byte_start":1242,"byte_end":1253,"line_start":38,"line_end":38,"column_start":24,"column_end":35,"is_primary":true,"text":[{"text":"                editor.delete_word();","highlight_start":24,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":15929,"byte_end":15942,"line_start":509,"line_end":509,"column_start":35,"column_end":48,"is_primary":false,"text":[{"text":"    pub fn delete_word(&mut self, forward: bool) {","highlight_start":35,"highlight_end":48}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":15906,"byte_end":15917,"line_start":509,"line_end":509,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"    pub fn delete_word(&mut self, forward: bool) {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"crates/editor/src/commands.rs","byte_start":1253,"byte_end":1255,"line_start":38,"line_end":38,"column_start":35,"column_end":37,"is_primary":true,"text":[{"text":"                editor.delete_word();","highlight_start":35,"highlight_end":37}],"label":null,"suggested_replacement":"(/* bool */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 1 argument but 0 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/commands.rs:38:24\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 editor.delete_word();\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94margument #1 of type `bool` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:509:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m509\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn delete_word(&mut self, forward: bool) {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m            \u001b[1m\u001b[94m-------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                editor.delete_word(\u001b[92m/* bool */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[92m++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed for `Vec<_>`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/selection.rs","byte_start":3612,"byte_end":3616,"line_start":141,"line_end":141,"column_start":37,"column_end":41,"is_primary":false,"text":[{"text":"                let (_, last_end) = last.range();","highlight_start":37,"highlight_end":41}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/selection.rs","byte_start":3421,"byte_end":3431,"line_start":137,"line_end":137,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"        let mut merged = Vec::with_capacity(self.selections.len());","highlight_start":13,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving `merged` an explicit type, where the placeholders `_` are specified","code":null,"level":"help","spans":[{"file_name":"crates/editor/src/selection.rs","byte_start":3431,"byte_end":3431,"line_start":137,"line_end":137,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"        let mut merged = Vec::with_capacity(self.selections.len());","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":": Vec<T>","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed for `Vec<_>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/selection.rs:137:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m137\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut merged = Vec::with_capacity(self.selections.len());\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m141\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let (_, last_end) = last.range();\n    \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `merged` an explicit type, where the placeholders `_` are specified\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m137\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let mut merged\u001b[92m: Vec<T>\u001b[0m = Vec::with_capacity(self.selections.len());\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":21980,"byte_end":21998,"line_start":679,"line_end":679,"column_start":20,"column_end":38,"is_primary":true,"text":[{"text":"            if let Some((start, end)) = word::word_at(content, offset) {","highlight_start":20,"highlight_end":38}],"label":"expected `(usize, usize)`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":22001,"byte_end":22031,"line_start":679,"line_end":679,"column_start":41,"column_end":71,"is_primary":false,"text":[{"text":"            if let Some((start, end)) = word::word_at(content, offset) {","highlight_start":41,"highlight_end":71}],"label":"this expression has type `(usize, usize)`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected tuple `(usize, usize)`\n    found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:679:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m679\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Some((start, end)) = word::word_at(content, offset) {\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m------------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `(usize, usize)`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91mexpected `(usize, usize)`, found `Option<_>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected tuple `\u001b[1m\u001b[35m(usize, usize)\u001b[0m`\n                found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":22493,"byte_end":22508,"line_start":698,"line_end":698,"column_start":16,"column_end":31,"is_primary":true,"text":[{"text":"        if let Some(selection) = self.selections.primary() {","highlight_start":16,"highlight_end":31}],"label":"expected `Selection`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":22511,"byte_end":22536,"line_start":698,"line_end":698,"column_start":34,"column_end":59,"is_primary":false,"text":[{"text":"        if let Some(selection) = self.selections.primary() {","highlight_start":34,"highlight_end":59}],"label":"this expression has type `&Selection`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Selection`\n     found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:698:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m698\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(selection) = self.selections.primary() {\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `&Selection`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91mexpected `Selection`, found `Option<_>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mSelection\u001b[0m`\n                 found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":22846,"byte_end":22861,"line_start":710,"line_end":710,"column_start":16,"column_end":31,"is_primary":true,"text":[{"text":"        if let Some(selection) = self.selections.primary() {","highlight_start":16,"highlight_end":31}],"label":"expected `Selection`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":22864,"byte_end":22889,"line_start":710,"line_end":710,"column_start":34,"column_end":59,"is_primary":false,"text":[{"text":"        if let Some(selection) = self.selections.primary() {","highlight_start":34,"highlight_end":59}],"label":"this expression has type `&Selection`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Selection`\n     found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:710:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m710\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(selection) = self.selections.primary() {\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `&Selection`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91mexpected `Selection`, found `Option<_>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mSelection\u001b[0m`\n                 found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"no method named `clear` found for struct `SelectionSet` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":27057,"byte_end":27062,"line_start":841,"line_end":841,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"            self.selections.clear();","highlight_start":29,"highlight_end":34}],"label":"method not found in `SelectionSet`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/selection.rs","byte_start":1751,"byte_end":1774,"line_start":70,"line_end":70,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"pub struct SelectionSet {","highlight_start":1,"highlight_end":24}],"label":"method `clear` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `clear` found for struct `SelectionSet` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:841:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m841\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             self.selections.clear();\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `SelectionSet`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0mcrates/editor/src/selection.rs:70:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct SelectionSet {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mmethod `clear` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `clear` found for struct `SelectionSet` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":27983,"byte_end":27988,"line_start":867,"line_end":867,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"            self.selections.clear();","highlight_start":29,"highlight_end":34}],"label":"method not found in `SelectionSet`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/selection.rs","byte_start":1751,"byte_end":1774,"line_start":70,"line_end":70,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"pub struct SelectionSet {","highlight_start":1,"highlight_end":24}],"label":"method `clear` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `clear` found for struct `SelectionSet` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:867:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m867\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             self.selections.clear();\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `SelectionSet`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0mcrates/editor/src/selection.rs:70:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct SelectionSet {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mmethod `clear` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":29611,"byte_end":29626,"line_start":915,"line_end":915,"column_start":16,"column_end":31,"is_primary":true,"text":[{"text":"        if let Some(selection) = self.selections.primary_mut() {","highlight_start":16,"highlight_end":31}],"label":"expected `Selection`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":29629,"byte_end":29658,"line_start":915,"line_end":915,"column_start":34,"column_end":63,"is_primary":false,"text":[{"text":"        if let Some(selection) = self.selections.primary_mut() {","highlight_start":34,"highlight_end":63}],"label":"this expression has type `&mut Selection`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Selection`\n     found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:915:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m915\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(selection) = self.selections.primary_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `&mut Selection`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91mexpected `Selection`, found `Option<_>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mSelection\u001b[0m`\n                 found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":31530,"byte_end":31545,"line_start":961,"line_end":961,"column_start":16,"column_end":31,"is_primary":true,"text":[{"text":"        if let Some(selection) = self.selections.primary_mut() {","highlight_start":16,"highlight_end":31}],"label":"expected `Selection`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":31548,"byte_end":31577,"line_start":961,"line_end":961,"column_start":34,"column_end":63,"is_primary":false,"text":[{"text":"        if let Some(selection) = self.selections.primary_mut() {","highlight_start":34,"highlight_end":63}],"label":"this expression has type `&mut Selection`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Selection`\n     found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:961:16\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m961\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(selection) = self.selections.primary_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `&mut Selection`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91mexpected `Selection`, found `Option<_>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mSelection\u001b[0m`\n                 found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":33550,"byte_end":33565,"line_start":1009,"line_end":1009,"column_start":16,"column_end":31,"is_primary":true,"text":[{"text":"        if let Some(selection) = self.selections.primary_mut() {","highlight_start":16,"highlight_end":31}],"label":"expected `Selection`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":33568,"byte_end":33597,"line_start":1009,"line_end":1009,"column_start":34,"column_end":63,"is_primary":false,"text":[{"text":"        if let Some(selection) = self.selections.primary_mut() {","highlight_start":34,"highlight_end":63}],"label":"this expression has type `&mut Selection`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Selection`\n     found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:1009:16\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1009\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(selection) = self.selections.primary_mut() {\n     \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `&mut Selection`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m|\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91mexpected `Selection`, found `Option<_>`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mSelection\u001b[0m`\n                  found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"`&Selection` is not an iterator","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":37079,"byte_end":37082,"line_start":1097,"line_end":1097,"column_start":56,"column_end":59,"is_primary":true,"text":[{"text":"            let cursor_pos = self.selections.primary().map(|s| s.head.offset).unwrap_or(0);","highlight_start":56,"highlight_end":59}],"label":"`&Selection` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/selection.rs","byte_start":171,"byte_end":191,"line_start":7,"line_end":7,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub struct Selection {","highlight_start":1,"highlight_end":21}],"label":"doesn't satisfy `Selection: Iterator`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`&Selection: Iterator`\nwhich is required by `&mut &Selection: Iterator`\n`Selection: Iterator`\nwhich is required by `&mut Selection: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the trait `Iterator` must be implemented","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/iter/traits/iterator.rs","byte_start":1514,"byte_end":1532,"line_start":40,"line_end":40,"column_start":1,"column_end":19,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `Iterator` defines an item `map`, but is explicitly unimplemented","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: `&Selection` is not an iterator\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:1097:56\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1097\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let cursor_pos = self.selections.primary().map(|s| s.head.offset).unwrap_or(0);\n     \u001b[1m\u001b[94m|\u001b[0m                                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91m`&Selection` is not an iterator\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m::: \u001b[0mcrates/editor/src/selection.rs:7:1\n     \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Selection {\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Selection: Iterator`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n             `&Selection: Iterator`\n             which is required by `&mut &Selection: Iterator`\n             `Selection: Iterator`\n             which is required by `&mut Selection: Iterator`\n\u001b[1m\u001b[92mnote\u001b[0m: the trait `Iterator` must be implemented\n    \u001b[1m\u001b[94m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/iter/traits/iterator.rs:40:1\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the trait `Iterator` defines an item `map`, but is explicitly unimplemented\n\n"}
{"$message_type":"diagnostic","message":"missing fields `regex` and `whole_word` in initializer of `FindState`","code":{"code":"E0063","explanation":"A struct's or struct-like enum variant's field was not provided.\n\nErroneous code example:\n\n```compile_fail,E0063\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\nEach field should be specified exactly once. Example:\n\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":37308,"byte_end":37317,"line_start":1105,"line_end":1105,"column_start":32,"column_end":41,"is_primary":true,"text":[{"text":"        self.find_query = Some(FindState {","highlight_start":32,"highlight_end":41}],"label":"missing `regex` and `whole_word`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0063]\u001b[0m\u001b[1m: missing fields `regex` and `whole_word` in initializer of `FindState`\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:1105:32\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1105\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.find_query = Some(FindState {\n     \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmissing `regex` and `whole_word`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":37916,"byte_end":37931,"line_start":1124,"line_end":1124,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"                if let Some(selection) = self.selections.primary_mut() {","highlight_start":24,"highlight_end":39}],"label":"expected `Selection`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":37934,"byte_end":37963,"line_start":1124,"line_end":1124,"column_start":42,"column_end":71,"is_primary":false,"text":[{"text":"                if let Some(selection) = self.selections.primary_mut() {","highlight_start":42,"highlight_end":71}],"label":"this expression has type `&mut Selection`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Selection`\n     found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:1124:24\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 if let Some(selection) = self.selections.primary_mut() {\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `&mut Selection`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m|\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91mexpected `Selection`, found `Option<_>`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mSelection\u001b[0m`\n                  found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":38652,"byte_end":38667,"line_start":1144,"line_end":1144,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"                if let Some(selection) = self.selections.primary_mut() {","highlight_start":24,"highlight_end":39}],"label":"expected `Selection`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":38670,"byte_end":38699,"line_start":1144,"line_end":1144,"column_start":42,"column_end":71,"is_primary":false,"text":[{"text":"                if let Some(selection) = self.selections.primary_mut() {","highlight_start":42,"highlight_end":71}],"label":"this expression has type `&mut Selection`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Selection`\n     found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:1144:24\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1144\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 if let Some(selection) = self.selections.primary_mut() {\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `&mut Selection`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m|\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91mexpected `Selection`, found `Option<_>`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mSelection\u001b[0m`\n                  found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":41130,"byte_end":41145,"line_start":1213,"line_end":1213,"column_start":16,"column_end":31,"is_primary":true,"text":[{"text":"        if let Some(selection) = self.selections.primary() {","highlight_start":16,"highlight_end":31}],"label":"expected `Selection`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":41148,"byte_end":41173,"line_start":1213,"line_end":1213,"column_start":34,"column_end":59,"is_primary":false,"text":[{"text":"        if let Some(selection) = self.selections.primary() {","highlight_start":34,"highlight_end":59}],"label":"this expression has type `&Selection`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Selection`\n     found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:1213:16\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1213\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if let Some(selection) = self.selections.primary() {\n     \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m   \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `&Selection`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91m|\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m                \u001b[1m\u001b[91mexpected `Selection`, found `Option<_>`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mSelection\u001b[0m`\n                  found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"used binding `m` is possibly-uninitialized","code":{"code":"E0381","explanation":"It is not allowed to use or capture an uninitialized variable.\n\nErroneous code example:\n\n```compile_fail,E0381\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly-uninitialized variable\n}\n```\n\nTo fix this, ensure that any declared variables are initialized before being\nused. Example:\n\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/input.rs","byte_start":4618,"byte_end":4625,"line_start":166,"line_end":166,"column_start":58,"column_end":65,"is_primary":true,"text":[{"text":"            (Key::Char('V'), _) | (Key::Char('v'), m) if m.shift => {","highlight_start":58,"highlight_end":65}],"label":"`m.shift` used here but it is possibly-uninitialized","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/input.rs","byte_start":4612,"byte_end":4613,"line_start":166,"line_end":166,"column_start":52,"column_end":53,"is_primary":false,"text":[{"text":"            (Key::Char('V'), _) | (Key::Char('v'), m) if m.shift => {","highlight_start":52,"highlight_end":53}],"label":"binding initialized here in some conditions","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/input.rs","byte_start":4612,"byte_end":4613,"line_start":166,"line_end":166,"column_start":52,"column_end":53,"is_primary":false,"text":[{"text":"            (Key::Char('V'), _) | (Key::Char('v'), m) if m.shift => {","highlight_start":52,"highlight_end":53}],"label":"binding declared here but left uninitialized","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0381]\u001b[0m\u001b[1m: used binding `m` is possibly-uninitialized\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/input.rs:166:58\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             (Key::Char('V'), _) | (Key::Char('v'), m) if m.shift => {\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94m-\u001b[0m     \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91m`m.shift` used here but it is possibly-uninitialized\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94mbinding initialized here in some conditions\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[94mbinding declared here but left uninitialized\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `bytes`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/editor/src/word.rs","byte_start":989,"byte_end":994,"line_start":39,"line_end":39,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"    let bytes = text.as_bytes();","highlight_start":9,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/editor/src/word.rs","byte_start":989,"byte_end":994,"line_start":39,"line_end":39,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"    let bytes = text.as_bytes();","highlight_start":9,"highlight_end":14}],"label":null,"suggested_replacement":"_bytes","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `bytes`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/word.rs:39:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bytes = text.as_bytes();\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_bytes`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":7093,"byte_end":7108,"line_start":269,"line_end":269,"column_start":31,"column_end":46,"is_primary":false,"text":[{"text":"        for (i, selection) in self.selections.iter_mut().enumerate() {","highlight_start":31,"highlight_end":46}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":7375,"byte_end":7379,"line_start":275,"line_end":275,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            self.push_edit(adjusted_offset..adjusted_offset, String::new(), text.to_string());","highlight_start":13,"highlight_end":17}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":7093,"byte_end":7131,"line_start":269,"line_end":269,"column_start":31,"column_end":69,"is_primary":false,"text":[{"text":"        for (i, selection) in self.selections.iter_mut().enumerate() {","highlight_start":31,"highlight_end":69}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":7093,"byte_end":7131,"line_start":269,"line_end":269,"column_start":31,"column_end":69,"is_primary":false,"text":[{"text":"        for (i, selection) in self.selections.iter_mut().enumerate() {","highlight_start":31,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:275:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for (i, selection) in self.selections.iter_mut().enumerate() {\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[94m--------------------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m275\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             self.push_edit(adjusted_offset..adjusted_offset, String::new(), text.to_string());\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":8109,"byte_end":8124,"line_start":296,"line_end":296,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":8517,"byte_end":8521,"line_start":304,"line_end":304,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.push_edit(offset..selection.head.offset, deleted, String::new());","highlight_start":21,"highlight_end":25}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":8109,"byte_end":8135,"line_start":296,"line_end":296,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":8109,"byte_end":8135,"line_start":296,"line_end":296,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:304:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m296\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m304\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.push_edit(offset..selection.head.offset, deleted, String::new());\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":8109,"byte_end":8124,"line_start":296,"line_end":296,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":9170,"byte_end":9174,"line_start":319,"line_end":319,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.push_edit(start..end, deleted, String::new());","highlight_start":17,"highlight_end":21}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":8109,"byte_end":8135,"line_start":296,"line_end":296,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":8109,"byte_end":8135,"line_start":296,"line_end":296,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:319:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m296\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m319\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.push_edit(start..end, deleted, String::new());\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":10093,"byte_end":10097,"line_start":341,"line_end":341,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.offset_for_line_delta(&buffer.content, selection.head.offset, -1)","highlight_start":21,"highlight_end":25}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":9753,"byte_end":9768,"line_start":335,"line_end":335,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":9753,"byte_end":9779,"line_start":335,"line_end":335,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":9753,"byte_end":9779,"line_start":335,"line_end":335,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `*self` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:341:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m335\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m341\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.offset_for_line_delta(&buffer.content, selection.head.offset, -1)\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":10277,"byte_end":10281,"line_start":345,"line_end":345,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.offset_for_line_delta(&buffer.content, selection.head.offset, 1)","highlight_start":21,"highlight_end":25}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":9753,"byte_end":9768,"line_start":335,"line_end":335,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":9753,"byte_end":9779,"line_start":335,"line_end":335,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":9753,"byte_end":9779,"line_start":335,"line_end":335,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `*self` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:345:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m335\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.offset_for_line_delta(&buffer.content, selection.head.offset, 1)\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":13182,"byte_end":13197,"line_start":444,"line_end":444,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":13835,"byte_end":13839,"line_start":457,"line_end":457,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"                    self.push_edit(offset..char_end, deleted, String::new());","highlight_start":21,"highlight_end":25}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":13182,"byte_end":13208,"line_start":444,"line_end":444,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":13182,"byte_end":13208,"line_start":444,"line_end":444,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:457:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m444\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m457\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.push_edit(offset..char_end, deleted, String::new());\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":13182,"byte_end":13197,"line_start":444,"line_end":444,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":14322,"byte_end":14326,"line_start":468,"line_end":468,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.push_edit(start..end, deleted, String::new());","highlight_start":17,"highlight_end":21}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":13182,"byte_end":13208,"line_start":444,"line_end":444,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":13182,"byte_end":13208,"line_start":444,"line_end":444,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:468:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m444\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m468\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.push_edit(start..end, deleted, String::new());\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":14873,"byte_end":14888,"line_start":484,"line_end":484,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":15412,"byte_end":15416,"line_start":496,"line_end":496,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"            self.push_edit(line_start..line_end, deleted, String::new());","highlight_start":13,"highlight_end":17}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":14873,"byte_end":14899,"line_start":484,"line_end":484,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"a temporary with access to the first borrow is created here ...","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":14873,"byte_end":14899,"line_start":484,"line_end":484,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"crates/editor/src/lib.rs","byte_start":15866,"byte_end":15867,"line_start":505,"line_end":505,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        }","highlight_start":9,"highlight_end":10}],"label":"... and the first borrow might be used here, when that temporary is dropped and runs the destructor for type `impl Iterator<Item = &mut Selection>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":14856,"byte_end":15867,"line_start":484,"line_end":505,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":9,"highlight_end":54},{"text":"            let offset = selection.head.offset;","highlight_start":1,"highlight_end":48},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            // Find line boundaries","highlight_start":1,"highlight_end":36},{"text":"            let line_start = buffer_content[..offset].rfind('\\n').map(|i| i + 1).unwrap_or(0);","highlight_start":1,"highlight_end":95},{"text":"            let line_end = buffer_content[offset..].find('\\n')","highlight_start":1,"highlight_end":63},{"text":"                .map(|i| offset + i + 1) // Include the newline","highlight_start":1,"highlight_end":64},{"text":"                .unwrap_or(buffer_content.len());","highlight_start":1,"highlight_end":50},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            let deleted = buffer_content[line_start..line_end].to_string();","highlight_start":1,"highlight_end":76},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            // Record undo","highlight_start":1,"highlight_end":27},{"text":"            self.push_edit(line_start..line_end, deleted, String::new());","highlight_start":1,"highlight_end":74},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            let mut buffer = self.buffer.write();","highlight_start":1,"highlight_end":50},{"text":"            buffer.content.replace_range(line_start..line_end, \"\");","highlight_start":1,"highlight_end":68},{"text":"            selection.head.offset = line_start.min(buffer.content.len());","highlight_start":1,"highlight_end":74},{"text":"            selection.anchor = selection.head;","highlight_start":1,"highlight_end":47},{"text":"            buffer.dirty = true;","highlight_start":1,"highlight_end":33},{"text":"            buffer.version += 1;","highlight_start":1,"highlight_end":33},{"text":"            break; // Process one line at a time for multi-cursor","highlight_start":1,"highlight_end":66},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:496:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m484\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94ma temporary with access to the first borrow is created here ...\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m496\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             self.push_edit(line_start..line_end, deleted, String::new());\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m505\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         }\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94m... and the first borrow might be used here, when that temporary is dropped and runs the destructor for type `impl Iterator<Item = &mut Selection>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":16045,"byte_end":16060,"line_start":512,"line_end":512,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":16601,"byte_end":16605,"line_start":525,"line_end":525,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.push_edit(start..end, old_text, String::new());","highlight_start":17,"highlight_end":21}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":16045,"byte_end":16071,"line_start":512,"line_end":512,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":16045,"byte_end":16071,"line_start":512,"line_end":512,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:525:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m512\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m525\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.push_edit(start..end, old_text, String::new());\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":17162,"byte_end":17177,"line_start":541,"line_end":541,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":17546,"byte_end":17550,"line_start":550,"line_end":550,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.push_edit(offset..line_end, deleted, String::new());","highlight_start":17,"highlight_end":21}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":17162,"byte_end":17188,"line_start":541,"line_end":541,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":17162,"byte_end":17188,"line_start":541,"line_end":541,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:550:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m541\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m550\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.push_edit(offset..line_end, deleted, String::new());\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"crates/editor/src/lib.rs","byte_start":18024,"byte_end":18039,"line_start":564,"line_end":564,"column_start":26,"column_end":41,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":41}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":18357,"byte_end":18361,"line_start":571,"line_end":571,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"                self.push_edit(line_start..offset, deleted, String::new());","highlight_start":17,"highlight_end":21}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/editor/src/lib.rs","byte_start":18024,"byte_end":18050,"line_start":564,"line_end":564,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/editor/src/lib.rs","byte_start":18024,"byte_end":18050,"line_start":564,"line_end":564,"column_start":26,"column_end":52,"is_primary":false,"text":[{"text":"        for selection in self.selections.iter_mut() {","highlight_start":26,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"crates/editor/src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `*self` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0mcrates/editor/src/lib.rs:571:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m564\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for selection in self.selections.iter_mut() {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m--------------------------\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m571\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.push_edit(line_start..offset, deleted, String::new());\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 28 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 28 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0063, E0282, E0308, E0381, E0408, E0499, E0502, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0061, E0063, E0282, E0308, E0381, E0408, E0499, E0502, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
